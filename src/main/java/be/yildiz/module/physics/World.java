//        This file is part of the Yildiz-Online project, licenced under the MIT License//        (MIT)////        Copyright (c) 2016 Grégory Van den Borre////        More infos available: http://yildiz.bitbucket.org////        Permission is hereby granted, free of charge, to any person obtaining a copy//        of this software and associated documentation files (the "Software"), to deal//        in the Software without restriction, including without limitation the rights//        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//        copies of the Software, and to permit persons to whom the Software is//        furnished to do so, subject to the following conditions:////        The above copyright notice and this permission notice shall be included in all//        copies or substantial portions of the Software.////        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE//        SOFTWARE.package be.yildiz.module.physics;import be.yildiz.common.id.EntityId;import be.yildiz.common.shape.Box;import be.yildiz.common.shape.Sphere;import be.yildiz.common.vector.Point3D;/** * Base interface for ClientWorld and ServerWorld, not meant ot be used as type but contains common code. * * @author Grégory Van den Borre */public interface World {    /**     * Throw a ray in 3D space and check if it collide with an object, this is much slower than the simple ray, use it only if the collision point is needed.     *     * @param origin      Ray starting point.     * @param destination Ray end point.     * @return An object containing the collided object and the collision point.     */    RaycastResult throwRay(Point3D origin, Point3D destination);    /**     * Throw a ray in 3D space and check if it collide with an object.     *     * @param origin      Ray starting point.     * @param destination Ray end point.     * @return The id of the collided object.     */    EntityId throwSimpleRay(Point3D origin, Point3D destination);    /**     * @return The current gravity applied on this world.     */    //@Ensures result != null    Point3D getGravity();    /**     * Set the gravity force for this world.     *     * @param newGravity Gravity value.     */    void setGravity(Gravity newGravity);    /**     * Set the gravity force for this world.     *     * @param gravityX Gravity value on X axis.     * @param gravityY Gravity value on Y axis.     * @param gravityZ Gravity value on Z axis.     */    void setGravity(float gravityX, float gravityY, float gravityZ);    /**     * Create a new ghost object, ghost object can be moved are not visible, and receive collision, it will not affect dynamic objects. Ghost collision are received from a separate listener @see     * GameEngine.addGhostCollisionListener method.     *     * @param id       Id retrieved when this ghost collide, must be unique.     * @param box      Ghost shape.     * @param position Initial object position.     * @return The built ghost object.     */    //@Ensures result != null    GhostObject createGhostObject(EntityId id, Box box, Point3D position);    /**     * Create a new ghost object, ghost object can be moved are not visible, and receive collision, it will not affect dynamic objects. Ghost collision are received from a separate listener @see     * GameEngine.addGhostCollisionListener method.     *     * @param id       Id retrieved when this ghost collide, must be unique.     * @param sphere   Ghost shape.     * @param position Initial object position.     * @return The built ghost object.     */    //@Ensures result != null    GhostObject createGhostObject(EntityId id, Sphere sphere, Point3D position);}